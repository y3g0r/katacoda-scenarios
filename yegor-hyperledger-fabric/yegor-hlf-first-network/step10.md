If we use `peer chaincode query` for chaincode operations which write to the ledger (use PutState API), we will get the response as if the data was altered, but it won't be actually committed.
`peer chaincode query -C mychannel -n mycc -c '{"Args":["invoke", "b", "a", "10"]}'`{{execute}}

`peer chaincode query -C mychannel -n mycc -c '{"Args":["query", "a"]}'`{{execute}}

## Peer chaincode invoke

In order to commit transaction we use `peer chaincode invoke` command.

The difference between `peer chaincode query` and `peer chaincode invoke` is as follows:

- Proposal is sent from client (cli in this case) to peer
- Peer deligates proposal to it's chaincode
- Chaincode perform read only interaction with the ledger to prepare read-write set
- Peer signs read-write set returned from chaincode, thus endorsing it
- Peer returns transaction simulation or endorsed proposal

`peer chaincode query` stops here.
`peer chaincode invoke` continues:

- The same operations as explained above are repeated for all provided peers
- Endorsment from all peers are collected by client and sent to orderer
- Orderer decides on order of transaction in current block and broadcasts new block once it's finished
- Peer receives new block, validate and commit transaction, adjusting ledger along the way

Let's try using `peer chaincode invoke` command.

```
peer chaincode invoke \
    -C mychannel -n mycc -c '{"Args":["invoke","b","a","10"]}'
```{{execute}}

This error output doesn't make a lot of sense, but as orderer is configured to use TLS (`ORDERER_GENERAL_TLS_ENABLED=true` in first-network/base/peer-base.yaml), let's explicitly enable it:

```
peer chaincode invoke \
    --tls true \
    -C mychannel -n mycc -c '{"Args":["invoke","b","a","10"]}'
```{{execute}}

So now, apparently there's a root certificate messing. Let's specify the one for orderer generated by `cryptogen` unitility when we did `./byfn.sh generate`

```
peer chaincode invoke \
    --tls true \
    --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem \
    -C mychannel -n mycc -c '{"Args":["invoke","b","a","10"]}'
```{{execute}}

Seems like now everything went well, right? Let's check:

`peer chaincode query -C mychannel -n mycc -c '{"Args":["query", "a"]}'`{{execute}}

No. We expected value of "a" increase by 10. So why does the log says 'Chaincode invoke successful'?
Well, turns out there's no lie. Chaincode work finished on read-write set generation. 
Actual write to ledger happens only when orderer creates new block with the transaction, 
and then transaction must be validated and committed. 
And we can wait for event which is emitted on transaction commit stage to see if it is actually applied with `--waitForEvent` flag.

```
peer chaincode invoke \
    --tls true \
    --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem \
    --waitForEvent \
    -C mychannel -n mycc -c '{"Args":["invoke","b","a","10"]}'
```{{execute}}

Now we can see that there is an ENDORSMENT_POLICY_FAILURE at the commit stage, but what does it mean?

Chaincodes have [endorsment policies](https://hyperledger-fabric.readthedocs.io/en/release-1.4/glossary.html#endorsement-policy). 
Those are set at the time of chaincode instantiation. Those endorsment policies tell how many peers from which organizations must endorse proposal in order for it to be valid.

If you take a closer look at code which instantiated "mycc" chaincode (instantiateChaincode function in fabric-sample/first-network/scripts/utils.sh) you will see this parameter passed: `-P "AND ('Org1MSP.peer','Org2MSP.peer')`. This endorsment policy tells that proposal mush be endorsed by members of 2 organization in order to meet the policy. So far we are invoking chaincode only on a single peer: peer0.org1.example.com which is a member of Org1MSP.

Let's add a peer from another organization. 

```
peer chaincode invoke \
    --tls true \
    --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem \
    --peerAddresses peer0.org2.example.com:9051 \
    --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt \
    --waitForEvent \
    -C mychannel -n mycc -c '{"Args":["invoke","b","a","10"]}'
```{{execute}}

Turns out if we explicitly specify peer in command line flags original peer from environment variables is not used and some of the environment variables conflict with flags specified as command line options, so lets include both peer0.org1 and peer0.org1 in command line options:

```
peer chaincode invoke \
    --tls true \
    --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem \
    --peerAddresses peer0.org1.example.com:7051 \
    --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt \
    --peerAddresses peer0.org2.example.com:9051 \
    --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt \
    --waitForEvent \
    -C mychannel -n mycc -c '{"Args":["invoke","b","a","10"]}'
```{{execute}}

Finally it looks ok, lets check using query:

`peer chaincode query -C mychannel -n mycc -c '{"Args":["query", "a"]}'`{{execute}}

In real life scenario you will hardly need to invoke chaincodes from CLI. 
For the purpose of invoking chaincode client application is normally developed using on of the provided SDKs.
Client application would then normally consume so-called connectionProfile file, in which all information about peers and orderers endpoints is supplied, including root CA certificates.

[Command reference](https://hyperledger-fabric.readthedocs.io/en/release-1.4/commands/peerchaincode.html#peer-chaincode-invoke)
